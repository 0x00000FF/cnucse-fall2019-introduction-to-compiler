/*
 *  Filename      : MiniCPrintLister.java
 *  Author        : 201704150 Kangjun Heo
 *  Written at    : 2019-10-12
 *  Modified at   : 2019-10-15
 *  Organization  : Undergraduated Student,
 *                  Department of Computer Science and Engineering,
 *                  Chungnam National University
 *  Package       : none
 *  Class         : MiniCPrintListener
 *  Extended From : generated.MiniCBaseListener
 *  Implements    : nothing
 *  Purpose       :
 *      The main purpose of MiniCPrintListener is to process
 *      MiniC Language with Walker Method, and being injected
 *      its dependency into ParseTreeWalker so that walk into
 *      parser workflow.
 *  Addendum      :
 *      I hate add comments my codes, why I have to?
 */

// Import required packages
// Package 'generated' contains essential classes generated by ANTLR
import generated.*;
import java.util.Vector;            // Vector<E>
import org.antlr.v4.runtime.tree.*; // For ParseTree, ParseTreeProperty

public class MiniCPrintListener extends MiniCBaseListener {
    // Code string builder (To Replace Stdout Print)
    private StringBuilder codeBuilder = new StringBuilder();

    // ParseTreeProperty objects
    ParseTreeProperty<String> params = new ParseTreeProperty<String>();
    ParseTreeProperty<String> compoundStmt = new ParseTreeProperty<String>();
    ParseTreeProperty<String> subCompoundStmt = new ParseTreeProperty<String>();

    // Indent Related States
    private int indentLevel = 0;

    // Constant: Default Amount of Indentation
    private final int indentSpaces = 4;

    // Utility Function: Builds complete code form
    public String build() {
        return (codeBuilder == null) ? null : codeBuilder.toString();
    }

    // Utility Function: Emit formatted code to codeBuilder
    // Replaces codeBuilder.append
    private void emit(String str) {
        codeBuilder.append(str + "\n");
    }

    // Utility Function: Indentation with dot(.)
    // repeat(int) method of String object can be used
    // for implementation of indentation, because such
    // feature requires repeated characters.
    private String createIndent() {
        return ".".repeat(indentLevel * indentSpaces);
    }

    // Utility Function: Space Concatenation
    // Each tokens should be concatenated with spaces
    // to achieve pretty print function,
    // thus it can be implemented with String.join
    private String concatWithSpaces(String...strs) {
        return String.join(" ", strs);
    }

    // Utility Function: Comma-Space Concatenation
    // Each parameter tokens should be contatenated with spaces
    // to schieve pretty print function,
    // it also can be implemented with String.join
    private String concatWithCommaSpaces(String... strs) {
        return String.join(", ", strs);
    }

    // Global Variable Declaration
    @Override public void exitVar_decl(MiniCParser.Var_declContext ctx) {
        String decl = "";

        // Global Variable Declaration has three rules that
        // are having 3, 5, 6 children
        // thus...
        switch (ctx.getChildCount()) {
            case 3:
                decl = concatWithSpaces(
                  ctx.type_spec().getText(),
                  ctx.IDENT().getText()
                );
                break;

            case 5:
                decl = concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText(),
                        "=",
                        ctx.LITERAL().getText()
                );
                break;

            case 6:
                decl = concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText().concat(
                                "[" + ctx.LITERAL().getText() + "]"
                        )
                );
                break;

            // This condition is not necessary to consider
            // But need to be handled
            default:
                return;
        }

        decl += ";";
        emit(decl);
    }

    // Local declaration
    public void exitLocal_decl(MiniCParser.Local_declContext ctx) {
        String decl = "";

        // Create Indent Dots
        // For more information,
        // Refer private method createIndent()
        // at MiniCPrintListener.java, Line 19
        decl += createIndent();

        // Local Variable Declaration has three rules that
        // are having 3, 5, 6 children
        // thus...
        switch (ctx.getChildCount()) {
            case 3:
                decl += concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText()
                );
                break;
            case 5:
                decl += concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText(),
                        "=",
                        ctx.LITERAL().getText()
                );
                break;
            case 6:
                decl += concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText().concat(
                                "[" + ctx.LITERAL().getText() + "]"
                        )
                );
                break;
        }

        subCompoundStmt.put(ctx, decl + ";");
    }

    // While Statement
    @Override public void exitWhile_stmt(MiniCParser.While_stmtContext ctx) {
        String whileStmtStart = concatWithSpaces(
                ctx.WHILE().getText(),
                "(" + ctx.expr().getText() + ")"
        );

        subCompoundStmt.put(ctx, whileStmtStart);
    }

    // Expression
    @Override public void exitExpr(MiniCParser.ExprContext ctx) {

    }

    // Compound Statements Declaration (Enter)
    @Override public void enterCompound_stmt(MiniCParser.Compound_stmtContext ctx) {
        compoundStmt = new ParseTreeProperty<String>();
    }

    // Compound Statements Declaration
    @Override public void exitCompound_stmt(MiniCParser.Compound_stmtContext ctx) {
        if (ctx.children == null) return;

        for (ParseTree pt : ctx.children) {
            // Low indent level before escaping compound statement
            if (pt.getText().equals("}")) {
                indentLevel--;
            }

            // Get Sub Compound Statements
            String subStatements = subCompoundStmt.get(pt);
            if (subStatements == null)
                subStatements = pt.getText();

            // Add Statement with Indentation
            compoundStmt.put(pt, createIndent() + subStatements);

            // Up indent level before entering compound statement
            if (pt.getText().equals("{")) {
                indentLevel++;
            }
        }
    }

    // Creates new ParseTreeProperty object
    // To store new
    @Override public void exitParams(MiniCParser.ParamsContext ctx) {
        params = new ParseTreeProperty<String>();

        if (ctx.children == null) return;

        for (ParseTree pt : ctx.children) {
            // Ignore comma (will concatenated)
            if (pt.getText().equals(",")) continue;

            // Create initial parameter declaration
            // type_spec INDENT
            String paramStr = pt.getChild(0).getText() + " " +
                              pt.getChild(1).getText();

            // Add array type brackets if parameter is array type
            if (pt.getChildCount() == 4)
                paramStr += "[]";

            params.put(pt, paramStr);
        }
    }

    // Function Declaration
    @Override public void exitFun_decl(MiniCParser.Fun_declContext ctx) {
        String funcBody = "";

        // Concatenates initial fragment of function declaration
        // type_spec IDENT(
        funcBody += concatWithSpaces(
                ctx.type_spec().getText(),
                ctx.IDENT().getText(),
                "("
        );

        // Concatenates function parameters
        // Getting from ParseTreeProperty<String> params
        MiniCParser.ParamsContext psctx = ctx.params();
        if (psctx.children != null) {
            Vector<String> l_Params = new Vector<String>();
            for (ParseTree param : psctx.children) {
                if (param.getText().equals(",")) continue;
                l_Params.add(params.get(param));
            }
            funcBody += concatWithCommaSpaces(l_Params.toArray(new String[0]));
        }

        // And closes parameter parenthesis
        // Also add line feed in order to place brace
        // on next line
        funcBody += ")\n";

        // Begin Compound Statements...
        MiniCParser.Compound_stmtContext compounds = ctx.compound_stmt();
        for (ParseTree compound : compounds.children) {
            funcBody += compoundStmt.get(compound).concat("\n");
        }

        emit(funcBody);
        super.exitFun_decl(ctx);
    }
}
