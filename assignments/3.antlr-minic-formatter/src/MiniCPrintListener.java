/*
 *  Filename      : MiniCPrintLister.java
 *  Author        : 201704150 Kangjun Heo
 *  Written at    : 2019-10-12
 *  Modified at   : 2019-10-15
 *  Organization  : Undergraduated Student,
 *                  Department of Computer Science and Engineering,
 *                  Chungnam National University
 *  Package       : none
 *  Class         : MiniCPrintListener
 *  Extended From : generated.MiniCBaseListener
 *  Implements    : nothing
 *  Purpose       :
 *      The main purpose of MiniCPrintListener is to process
 *      MiniC Language with Walker Method, and being injected
 *      its dependency into ParseTreeWalker so that walk into
 *      parser workflow.
 *  Addendum      :
 *      I hate add comments my codes, why I have to?
 */

// Import required packages
// Package 'generated' contains essential classes generated by ANTLR
import generated.*;
import java.util.Vector;            // Vector<E>
import org.antlr.v4.runtime.tree.*; // For ParseTree, ParseTreeProperty


public class MiniCPrintListener extends MiniCBaseListener {
    // ParseTreeProperty objects
    ParseTreeProperty<String> params = new ParseTreeProperty<String>();
    ParseTreeProperty<String> compountStmt = new ParseTreeProperty<String>();

    // Indent Related States
    private int indentLevel = 0;

    // Constant: Default Amount of Indentation
    private final int indentSpaces = 4;

    // Utility Function: Indentation with dot(.)
    // repeat(int) method of String object can be used
    // for implementation of indentation, because such
    // feature requires repeated characters.
    private String createIndent() {
        return ".".repeat(indentLevel * indentSpaces);
    }

    // Utility Function: Space Concatenation
    // Each tokens should be concatenated with spaces
    // to achieve pretty print function,
    // thus it can be implemented with String.join
    private String concatWithSpaces(String...strs) {
        return String.join(" ", strs);
    }

    // Utility Function: Comma-Space Concatenation
    // Each parameter tokens should be contatenated with spaces
    // to schieve pretty print function,
    // it also can be implemented with String.join
    private String concatWithCommaSpaces(String... strs) {
        return String.join(", ", strs);
    }

    // Global Variable Declaration
    @Override public void exitVar_decl(MiniCParser.Var_declContext ctx) {
        String decl = "";

        // Global Variable Declaration has three rules that
        // are having 3, 5, 6 children
        // thus...
        switch (ctx.getChildCount()) {
            case 3:
                decl = concatWithSpaces(
                  ctx.type_spec().getText(),
                  ctx.IDENT().getText()
                );
                break;

            case 5:
                decl = concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText(),
                        "=",
                        ctx.LITERAL().getText()
                );
                break;

            case 6:
                decl = concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText().concat(
                                "[" + ctx.LITERAL().getText() + "]"
                        )
                );
                break;

            // This condition is not necessary to consider
            // But need to be handled
            default:
                return;
        }

        decl += ";";
        System.out.println(decl);
    }

    // Local Variable Declaration
    // WHY
    @Override public void exitLocal_decl(MiniCParser.Local_declContext ctx) {
        String decl = "";

        // Create Indent Dots
        // For more information,
        // Refer private method createIndent()
        // at MiniCPrintListener.java, Line 19
        decl += createIndent();

        // Local Variable Declaration has three rules that
        // are having 3, 5, 6 children
        // thus...
        switch (ctx.getChildCount()) {
            case 3:
                decl += concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText()
                );
                break;
            case 5:
                decl += concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText(),
                        "=",
                        ctx.LITERAL().getText()
                );
                break;
            case 6:
                decl += concatWithSpaces(
                        ctx.type_spec().getText(),
                        ctx.IDENT().getText().concat(
                                "[" + ctx.LITERAL().getText() + "]"
                        )
                );
                break;

            // This condition is not necessary to consider
            // But need to be handled
            default:
                return;
        }

        decl += ";";
        System.out.println(decl);
    }

    // Compound Statements Declaration
    @Override public void exitCompound_stmt(MiniCParser.Compound_stmtContext ctx) {

    }

    // Creates new ParseTreeProperty object
    // To store new
    @Override public void exitParams(MiniCParser.ParamsContext ctx) {
        params = new ParseTreeProperty<String>();

        if (ctx.children == null) return;

        for (MiniCParser.ParamContext pt : ctx.children) {

            params.put(pt);
        }
    }

    // Function Declaration
    @Override public void exitFun_decl(MiniCParser.Fun_declContext ctx) {
        String funcBody = "";

        // Concatenates initial fragment of function declaration
        // type_spec IDENT(
        funcBody += concatWithSpaces(
                ctx.type_spec().getText(),
                ctx.IDENT().getText(),
                "("
        );

        // Concatenates function parameters
        // Getting from ParseTreeProperty<String> params
        MiniCParser.ParamsContext psctx = ctx.params();
        if (psctx.children != null) {
            String[] l_Params = new String[psctx.children.size()];
            for (int i = 0; i < l_Params.length; ++i) {
                l_Params[i] = params.get(psctx.children.get(i));
            }
            funcBody += concatWithCommaSpaces(l_Params);
        }

        // And closes parameter parenthesis
        // Also add line feed in order to place brace
        // on next line
        funcBody += ")";

        // Begin Compound Statements...

        System.out.println(funcBody);
        super.exitFun_decl(ctx);
    }
}
